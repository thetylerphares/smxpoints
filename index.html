<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>AMA Supercross Standings</title>

  <style>
    :root {
      --row-h: 48px;
      --rows-visible: 4;

      --bg: #000;
      --card: #111;
      --border: #222;
      --text: #fff;
      --muted: rgba(255,255,255,0.55);
      --pts: #4CAF50;

      /* Continuous scroll speed (pixels per second). Lower = slower */
      --scroll-speed: 22;
    }

    body {
      margin: 0;
      padding: 18px;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, sans-serif;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 18px;
    }

    .card {
      background: var(--card);
      border-radius: 14px;
      padding: 14px;
      border: 1px solid #151515;
      display: flex;
      flex-direction: column;
    }

    .cardHeader {
      position: sticky;
      top: 0;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      padding-bottom: 6px;
      z-index: 5;
    }

    h2 {
      margin: 0;
      text-align: center;
      font-size: 23px;
      padding: 6px 0 4px 0;
    }

    .colHeader {
      display: grid;
      grid-template-columns: 40px 1fr 70px;
      font-size: 12px;
      color: var(--muted);
    }

    .colHeader div:last-child {
      text-align: right;
    }

    /* Viewport shows exactly 4 rows */
    .viewport {
      height: calc(var(--row-h) * var(--rows-visible));
      overflow: hidden;
      margin-top: 8px;
      position: relative;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }

    tr { height: var(--row-h); }

    td {
      border-bottom: 1px solid var(--border);
      vertical-align: middle;
      font-size: 19px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    td.rank {
      width: 40px;
      padding-left: 4px;
      opacity: 0.75;
    }

    td.name { padding-left: 8px; }

    td.pts {
      width: 70px;
      text-align: right;
      font-size: 21px;
      font-weight: bold;
      color: var(--pts);
      padding-right: 4px;
    }

    .logo {
      height: 18px;
      margin-right: 6px;
      vertical-align: middle;
      filter: brightness(1.1);
    }

    .updated {
      margin-top: 8px;
      text-align: center;
      font-size: 12px;
      opacity: 0.55;
    }

    .error {
      padding: 10px;
      color: #ff6666;
      text-align: center;
      font-size: 14px;
    }

    /* Continuous scroller:
       We animate .track upward by exactly one list height (half the duplicated content). */
    .track {
      will-change: transform;
      transform: translateY(0);
    }

    .track.scrolling {
      animation-name: marquee;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
      animation-duration: var(--marquee-duration, 30s);
    }

    @keyframes marquee {
      from { transform: translateY(0); }
      to   { transform: translateY(calc(-1 * var(--marquee-distance, 0px))); }
    }
  </style>
</head>
<body>

<div class="grid">
  <div class="card">
    <div class="cardHeader">
      <h2>450SX</h2>
      <div class="colHeader"><div>#</div><div>Rider</div><div>PTS</div></div>
    </div>
    <div class="viewport">
      <div id="c450" class="track"></div>
    </div>
    <div id="u450" class="updated"></div>
  </div>

  <div class="card">
    <div class="cardHeader">
      <h2>250 West</h2>
      <div class="colHeader"><div>#</div><div>Rider</div><div>PTS</div></div>
    </div>
    <div class="viewport">
      <div id="c250w" class="track"></div>
    </div>
    <div id="u250w" class="updated"></div>
  </div>

  <div class="card">
    <div class="cardHeader">
      <h2>250 East</h2>
      <div class="colHeader"><div>#</div><div>Rider</div><div>PTS</div></div>
    </div>
    <div class="viewport">
      <div id="c250e" class="track"></div>
    </div>
    <div id="u250e" class="updated"></div>
  </div>
</div>

<script>
const BASE = "https://smxstanding.tylerphares.workers.dev";

const ROW_H = 48;
const VISIBLE = 4;
const MAX_DISPLAY = 20;

// pixels per second (matches --scroll-speed in :root)
const SCROLL_PX_PER_SEC = 22;

function escapeHtml(str) {
  return String(str)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function buildTable(list) {
  return `
    <table>
      <tbody>
        ${list.map(r => `
          <tr>
            <td class="rank">${r.rank}</td>
            <td class="name">
              ${r.logo ? `<img src="${r.logo}" class="logo" alt="">` : ""}
              ${escapeHtml(r.name)}
            </td>
            <td class="pts">${r.points}</td>
          </tr>
        `).join("")}
      </tbody>
    </table>
  `;
}

/**
 * Make a seamless loop:
 * - render list once
 * - render it again immediately after
 * - animate the wrapper up by exactly (list.length * ROW_H)
 */
function applyContinuousScroll(containerEl, listLength) {
  // Stop animation first (so restart is clean after refresh)
  containerEl.classList.remove("scrolling");
  containerEl.style.removeProperty("--marquee-distance");
  containerEl.style.removeProperty("--marquee-duration");

  // If there aren't enough rows to scroll, do nothing
  if (listLength <= VISIBLE) return;

  const distancePx = listLength * ROW_H;               // scroll one full list
  const durationSec = distancePx / SCROLL_PX_PER_SEC;  // constant speed

  containerEl.style.setProperty("--marquee-distance", `${distancePx}px`);
  containerEl.style.setProperty("--marquee-duration", `${durationSec}s`);

  // Force reflow so the animation reliably restarts
  void containerEl.offsetHeight;

  containerEl.classList.add("scrolling");
}

async function render(cls, containerId, updatedId) {
  const container = document.getElementById(containerId);
  const updatedEl = document.getElementById(updatedId);

  try {
    const res = await fetch(`${BASE}/?class=${cls}`, { cache: "no-store" });
    if (!res.ok) throw new Error("Fetch failed");

    const data = await res.json();
    let list = data.standings || [];

    if (!list.length) {
      container.classList.remove("scrolling");
      container.innerHTML = `<div class="error">No data</div>`;
      updatedEl.textContent = "";
      return;
    }

    // Make sure weâ€™re still points-leaders + ranks are sequential
    list.sort((a,b) => (b.points - a.points) || String(a.name).localeCompare(String(b.name)));
    list = list.slice(0, MAX_DISPLAY).map((r, i) => ({ ...r, rank: i + 1 }));

    // Duplicate the list for seamless loop
    const doubled = list.concat(list);

    container.innerHTML = buildTable(doubled);
    updatedEl.textContent = `Updated: ${new Date(data.updatedAt).toLocaleString()}`;

    applyContinuousScroll(container, list.length);

  } catch (e) {
    container.classList.remove("scrolling");
    container.innerHTML = `<div class="error">Load error</div>`;
    updatedEl.textContent = "";
  }
}

function loadAll() {
  render("450",  "c450",  "u450");
  render("250w", "c250w", "u250w");
  render("250e", "c250e", "u250e");
}

loadAll();
setInterval(loadAll, 10 * 60 * 1000);
</script>

</body>
</html>
